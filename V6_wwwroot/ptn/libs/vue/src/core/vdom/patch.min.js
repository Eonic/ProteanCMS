/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/vue@2.6.14/src/core/vdom/patch.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import VNode,{cloneVNode}from"./vnode";import config from"../config";import{SSR_ATTR}from"shared/constants";import{registerRef}from"./modules/ref";import{traverse}from"../observer/traverse";import{activeInstance}from"../instance/lifecycle";import{isTextInputType}from"web/util/element";import{warn,isDef,isUndef,isTrue,makeMap,isRegExp,isPrimitive}from"../util/index";export const emptyNode=new VNode("",{},[]);const hooks=["create","activate","update","remove","destroy"];function sameVnode(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&isDef(e.data)===isDef(t.data)&&sameInputType(e,t)||isTrue(e.isAsyncPlaceholder)&&isUndef(t.asyncFactory.error))}function sameInputType(e,t){if("input"!==e.tag)return!0;let n;const s=isDef(n=e.data)&&isDef(n=n.attrs)&&n.type,o=isDef(n=t.data)&&isDef(n=n.attrs)&&n.type;return s===o||isTextInputType(s)&&isTextInputType(o)}function createKeyToOldIdx(e,t,n){let s,o;const i={};for(s=t;s<=n;++s)o=e[s].key,isDef(o)&&(i[o]=s);return i}export function createPatchFunction(e){let t,n;const s={},{modules:o,nodeOps:i}=e;for(t=0;t<hooks.length;++t)for(s[hooks[t]]=[],n=0;n<o.length;++n)isDef(o[n][hooks[t]])&&s[hooks[t]].push(o[n][hooks[t]]);function r(e){const t=i.parentNode(e);isDef(t)&&i.removeChild(t,e)}function f(e,t){return!t&&!e.ns&&!(config.ignoredElements.length&&config.ignoredElements.some((t=>isRegExp(t)?t.test(e.tag):t===e.tag)))&&config.isUnknownElement(e.tag)}let c=0;function a(e,t,n,o,r,a,p){if(isDef(e.elm)&&isDef(a)&&(e=a[p]=cloneVNode(e)),e.isRootInsert=!r,function(e,t,n,o){let i=e.data;if(isDef(i)){const r=isDef(e.componentInstance)&&i.keepAlive;if(isDef(i=i.hook)&&isDef(i=i.init)&&i(e,!1),isDef(e.componentInstance))return l(e,t),d(n,e.elm,o),isTrue(r)&&function(e,t,n,o){let i,r=e;for(;r.componentInstance;)if(r=r.componentInstance._vnode,isDef(i=r.data)&&isDef(i=i.transition)){for(i=0;i<s.activate.length;++i)s.activate[i](emptyNode,r);t.push(r);break}d(n,e.elm,o)}(e,t,n,o),!0}}(e,t,n,o))return;const h=e.data,g=e.children,y=e.tag;if(isDef(y)){if("production"!==process.env.NODE_ENV&&(h&&h.pre&&c++,f(e,c)&&warn("Unknown custom element: <"+y+'> - did you register the component correctly? For recursive components, make sure to provide the "name" option.',e.context)),e.elm=e.ns?i.createElementNS(e.ns,y):i.createElement(y,e),D(e),__WEEX__){const s=isDef(h)&&isTrue(h.appendAsTree);s||(isDef(h)&&u(e,t),d(n,e.elm,o)),m(e,g,t),s&&(isDef(h)&&u(e,t),d(n,e.elm,o))}else m(e,g,t),isDef(h)&&u(e,t),d(n,e.elm,o);"production"!==process.env.NODE_ENV&&h&&h.pre&&c--}else isTrue(e.isComment)?(e.elm=i.createComment(e.text),d(n,e.elm,o)):(e.elm=i.createTextNode(e.text),d(n,e.elm,o))}function l(e,t){isDef(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,p(e)?(u(e,t),D(e)):(registerRef(e),t.push(e))}function d(e,t,n){isDef(e)&&(isDef(n)?i.parentNode(n)===e&&i.insertBefore(e,t,n):i.appendChild(e,t))}function m(e,t,n){if(Array.isArray(t)){"production"!==process.env.NODE_ENV&&T(t);for(let s=0;s<t.length;++s)a(t[s],n,e.elm,null,!0,t,s)}else isPrimitive(e.text)&&i.appendChild(e.elm,i.createTextNode(String(e.text)))}function p(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return isDef(e.tag)}function u(e,n){for(let t=0;t<s.create.length;++t)s.create[t](emptyNode,e);t=e.data.hook,isDef(t)&&(isDef(t.create)&&t.create(emptyNode,e),isDef(t.insert)&&n.push(e))}function D(e){let t;if(isDef(t=e.fnScopeId))i.setStyleScope(e.elm,t);else{let n=e;for(;n;)isDef(t=n.context)&&isDef(t=t.$options._scopeId)&&i.setStyleScope(e.elm,t),n=n.parent}isDef(t=activeInstance)&&t!==e.context&&t!==e.fnContext&&isDef(t=t.$options._scopeId)&&i.setStyleScope(e.elm,t)}function h(e,t,n,s,o,i){for(;s<=o;++s)a(n[s],i,e,t,!1,n,s)}function g(e){let t,n;const o=e.data;if(isDef(o))for(isDef(t=o.hook)&&isDef(t=t.destroy)&&t(e),t=0;t<s.destroy.length;++t)s.destroy[t](e);if(isDef(t=e.children))for(n=0;n<e.children.length;++n)g(e.children[n])}function y(e,t,n){for(;t<=n;++t){const n=e[t];isDef(n)&&(isDef(n.tag)?(v(n),g(n)):r(n.elm))}}function v(e,t){if(isDef(t)||isDef(e.data)){let n;const o=s.remove.length+1;for(isDef(t)?t.listeners+=o:t=function(e,t){function n(){0==--n.listeners&&r(e)}return n.listeners=t,n}(e.elm,o),isDef(n=e.componentInstance)&&isDef(n=n._vnode)&&isDef(n.data)&&v(n,t),n=0;n<s.remove.length;++n)s.remove[n](e,t);isDef(n=e.data.hook)&&isDef(n=n.remove)?n(e,t):t()}else r(e.elm)}function T(e){const t={};for(let n=0;n<e.length;n++){const s=e[n],o=s.key;isDef(o)&&(t[o]?warn(`Duplicate keys detected: '${o}'. This may cause an update error.`,s.context):t[o]=!0)}}function N(e,t,n,s){for(let o=n;o<s;o++){const n=t[o];if(isDef(n)&&sameVnode(e,n))return o}}function k(e,t,n,o,r,f){if(e===t)return;isDef(t.elm)&&isDef(o)&&(t=o[r]=cloneVNode(t));const c=t.elm=e.elm;if(isTrue(e.isAsyncPlaceholder))return void(isDef(t.asyncFactory.resolved)?V(e.elm,t,n):t.isAsyncPlaceholder=!0);if(isTrue(t.isStatic)&&isTrue(e.isStatic)&&t.key===e.key&&(isTrue(t.isCloned)||isTrue(t.isOnce)))return void(t.componentInstance=e.componentInstance);let l;const d=t.data;isDef(d)&&isDef(l=d.hook)&&isDef(l=l.prepatch)&&l(e,t);const m=e.children,u=t.children;if(isDef(d)&&p(t)){for(l=0;l<s.update.length;++l)s.update[l](e,t);isDef(l=d.hook)&&isDef(l=l.update)&&l(e,t)}isUndef(t.text)?isDef(m)&&isDef(u)?m!==u&&function(e,t,n,s,o){let r,f,c,l,d=0,m=0,p=t.length-1,u=t[0],D=t[p],g=n.length-1,v=n[0],x=n[g];const I=!o;for("production"!==process.env.NODE_ENV&&T(n);d<=p&&m<=g;)isUndef(u)?u=t[++d]:isUndef(D)?D=t[--p]:sameVnode(u,v)?(k(u,v,s,n,m),u=t[++d],v=n[++m]):sameVnode(D,x)?(k(D,x,s,n,g),D=t[--p],x=n[--g]):sameVnode(u,x)?(k(u,x,s,n,g),I&&i.insertBefore(e,u.elm,i.nextSibling(D.elm)),u=t[++d],x=n[--g]):sameVnode(D,v)?(k(D,v,s,n,m),I&&i.insertBefore(e,D.elm,u.elm),D=t[--p],v=n[++m]):(isUndef(r)&&(r=createKeyToOldIdx(t,d,p)),f=isDef(v.key)?r[v.key]:N(v,t,d,p),isUndef(f)?a(v,s,e,u.elm,!1,n,m):(c=t[f],sameVnode(c,v)?(k(c,v,s,n,m),t[f]=void 0,I&&i.insertBefore(e,c.elm,u.elm)):a(v,s,e,u.elm,!1,n,m)),v=n[++m]);d>p?(l=isUndef(n[g+1])?null:n[g+1].elm,h(e,l,n,m,g,s)):m>g&&y(t,d,p)}(c,m,u,n,f):isDef(u)?("production"!==process.env.NODE_ENV&&T(u),isDef(e.text)&&i.setTextContent(c,""),h(c,null,u,0,u.length-1,n)):isDef(m)?y(m,0,m.length-1):isDef(e.text)&&i.setTextContent(c,""):e.text!==t.text&&i.setTextContent(c,t.text),isDef(d)&&isDef(l=d.hook)&&isDef(l=l.postpatch)&&l(e,t)}function x(e,t,n){if(isTrue(n)&&isDef(e.parent))e.parent.data.pendingInsert=t;else for(let e=0;e<t.length;++e)t[e].data.hook.insert(t[e])}let I=!1;const E=makeMap("attrs,class,staticClass,staticStyle,key");function V(e,t,n,s){let o;const{tag:i,data:r,children:c}=t;if(s=s||r&&r.pre,t.elm=e,isTrue(t.isComment)&&isDef(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if("production"!==process.env.NODE_ENV&&!function(e,t,n){return isDef(t.tag)?0===t.tag.indexOf("vue-component")||!f(t,n)&&t.tag.toLowerCase()===(e.tagName&&e.tagName.toLowerCase()):e.nodeType===(t.isComment?8:3)}(e,t,s))return!1;if(isDef(r)&&(isDef(o=r.hook)&&isDef(o=o.init)&&o(t,!0),isDef(o=t.componentInstance)))return l(t,n),!0;if(isDef(i)){if(isDef(c))if(e.hasChildNodes())if(isDef(o=r)&&isDef(o=o.domProps)&&isDef(o=o.innerHTML)){if(o!==e.innerHTML)return"production"===process.env.NODE_ENV||"undefined"==typeof console||I||(I=!0,console.warn("Parent: ",e),console.warn("server innerHTML: ",o),console.warn("client innerHTML: ",e.innerHTML)),!1}else{let t=!0,o=e.firstChild;for(let e=0;e<c.length;e++){if(!o||!V(o,c[e],n,s)){t=!1;break}o=o.nextSibling}if(!t||o)return"production"===process.env.NODE_ENV||"undefined"==typeof console||I||(I=!0,console.warn("Parent: ",e),console.warn("Mismatching childNodes vs. VNodes: ",e.childNodes,c)),!1}else m(t,c,n);if(isDef(r)){let e=!1;for(const s in r)if(!E(s)){e=!0,u(t,n);break}!e&&r.class&&traverse(r.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,o){if(isUndef(t))return void(isDef(e)&&g(e));let r=!1;const f=[];if(isUndef(e))r=!0,a(t,f);else{const r=isDef(e.nodeType);if(!r&&sameVnode(e,t))k(e,t,f,null,null,o);else{if(r){if(1===e.nodeType&&e.hasAttribute(SSR_ATTR)&&(e.removeAttribute(SSR_ATTR),n=!0),isTrue(n)){if(V(e,t,f))return x(t,f,!0),e;"production"!==process.env.NODE_ENV&&warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.")}c=e,e=new VNode(i.tagName(c).toLowerCase(),{},[],void 0,c)}const o=e.elm,l=i.parentNode(o);if(a(t,f,o._leaveCb?null:l,i.nextSibling(o)),isDef(t.parent)){let e=t.parent;const n=p(t);for(;e;){for(let t=0;t<s.destroy.length;++t)s.destroy[t](e);if(e.elm=t.elm,n){for(let t=0;t<s.create.length;++t)s.create[t](emptyNode,e);const t=e.data.hook.insert;if(t.merged)for(let e=1;e<t.fns.length;e++)t.fns[e]()}else registerRef(e);e=e.parent}}isDef(l)?y([e],0,0):isDef(e.tag)&&g(e)}}var c;return x(t,f,r),t.elm}}
//# sourceMappingURL=/sm/227c9e612c3186bc199008f8937edfeef2a5491b980a32c38323692fa28db5cf.map